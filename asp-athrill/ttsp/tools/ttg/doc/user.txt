
	TTG - TOPPERS Test Generator -
	ユーザーズマニュアル

----------------------------------------------------------------------
 TTG
     TOPPERS Test Generator

 Copyright (C) 2009-2012 by Center for Embedded Computing Systems
             Graduate School of Information Science, Nagoya Univ., JAPAN
 Copyright (C) 2010-2011 by Graduate School of Information Science,
                            Aichi Prefectural Univ., JAPAN
 Copyright (C) 2012 by FUJISOFT INCORPORATED

 上記著作権者は，以下の (1)〜(3) の条件を満たす場合に限り，本ドキュメ
 ント(本ドキュメントを改変したものを含む．以下同じ)を使用・複製・改
 変・再配布(以下，利用と呼ぶ)することを無償で許諾する．
 (1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
     および下記の無保証規定が，そのままの形でドキュメント中に含まれて
     いること．
 (2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
     を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
     ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
     りではない．
 (3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
     からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
     本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
     く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

 本ドキュメントは，無保証で提供されているものである．上記著作権者およ
 びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
 る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
 により直接的または間接的に生じたいかなる損害に関しても，その責任を負
 わない．

 $Id: user.txt 2 2012-05-09 02:23:52Z nces-shigihara $
----------------------------------------------------------------------

本ドキュメントは，テストプログラム生成ツールTTGの使用方法，および生成し
たテストプログラムの実行方法について説明するものである．

○目次

(1) 用語定義
(2) 概要
	(2.1) TESRYデータの概要
		(2.1.1) pre_condition (前状態)
		(2.1.2) do (テスト内容)
		(2.1.3) post_condition(後状態)
	(2.2) 生成されるテストプログラムの概要
	(2.3) テストプログラムでチェックする内容
(3) 動作環境
	(3.1) TTGの実行環境
	(3.2) 生成するテストプログラムの対応カーネル
	(3.3) ビルドに必要なテストライブラリ
(4) テストライブラリへのリンク
	(4.1) 代替API
	(4.2) ターゲット依存API
	(4.3) ターゲット依存マクロ
(5) ASPカーネル用のターゲット依存APIの仕様
	(5.1) void ttsp_target_stop_tick(void)
	(5.2) void ttsp_target_start_tick(void)
	(5.3) void ttsp_target_gain_tick(void)
	(5.4) void ttsp_int_raise(INTNO intno)
	(5.5) void ttsp_clear_int_req(INTNO intno)
	(5.6) void ttsp_cpuexc_raise(EXCNO excno)
	(5.7) void ttsp_cpuexc_hook(EXCNO excno, void* p_excinf)
	(5.8) SIZE ttsp_target_get_stksz(TINIB *p_tinib)
	(5.9) void* ttsp_target_get_stk(TINIB *p_tinib)
(6) FMPカーネル用のターゲット依存APIの仕様
	(6.1) void ttsp_target_stop_tick(void)
	(6.2) void ttsp_target_start_tick(void)
	(6.3) void ttsp_target_gain_tick_pe(ID prcid, bool_t wait_flg)
	(6.4) void ttsp_target_gain_tick(void)
	(6.5) void ttsp_int_raise(INTNO intno)
	(6.6) void ttsp_clear_int_req(INTNO intno)
	(6.7) void ttsp_cpuexc_raise(EXCNO excno)
	(6.8) void ttsp_cpuexc_hook(EXCNO excno, void* p_excinf)
	(6.9) SIZE ttsp_target_get_stksz(TINIB *p_tinib)
	(6.10) void* ttsp_target_get_stk(TINIB *p_tinib)
(7) TTGによるテスト実施手順
	(7.1) TTG設定ファイル(configure.yaml)
	(7.2) テストプログラム生成
	(7.3) TTG実行時のエラー表示
	(7.4) バリエーション判別
	(7.5) 実行モジュールの作成
	(7.6) テスト実行
	(7.7) テスト実行結果の確認
(8) configure.yaml設定時の注意事項
	(8.1) ターゲット依存マクロの定義に関して
	(8.2) ターゲット依存APIの実装に関して
		(8.2.1) システム時刻制御関数
		(8.2.2) 割込み発生関数
		(8.2.3) CPU例外発生関数
(9) 実行時オプション
	(9.1) 標準オプション
	(9.2) プロファイル選択(いずれか必須)
	(9.3) TTGオプション
	(9.4) ロングオプションによるconfigure.yaml設定値の上書き
(10) GCOV機能
(11) テストプログラムに関する特記事項
	(11.1) 全TESRYデータを跨って使用する処理単位
	(11.2) スピンロックの共有
	(11.3) TA_STA属性の周期ハンドラ
	(11.4) TA_ENAINT属性の割込みハンドラ，割込み処理ルーチン
	(11.5) 前状態における割込み優先度マスクの設定
	(11.6) グローバルタイマ方式指定時の置換処理

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(1) 用語定義
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
本ドキュメントで使用する用語を定義する．なおTOPPERS新世代カーネル統合仕
様書に定義されている用語については，ここでは定義しないため，必要に応じ
てTOPPERS新世代カーネル統合仕様書を参考にすること．

■TOPPERS Test Generator (TTG)
  本テストプログラム生成ツールの名称．

■TOPPERS Test Cheacker (TTC)
  TTG内で使用するモジュールの名称．
  テストプログラム生成における前処理とチェック処理を担当する．

■TOPPERS Test Japanizer (TTJ)
  TTG内で使用するモジュールの名称．
  TTGの入力データの内容を日本語化して出力する．

■TESRY(TEst Scenario for Rtos by Yaml)記法
  TTGの入力データとなるテストシナリオを構造化して記述する記法．
  ※詳細はtesry_spec.txtを参照

■TESRYデータ
  TTGの入力データ．
  TESRY記法によって記述されたYAML形式のテストシナリオ．

■テストプログラム
  TTGが生成するc，h，cfgの3ファイル．

■管理タスク
  テストプログラムにおいて，システム状態の確認や，テスト実行の制御を行
  うために，テストシナリオとは別に用意するタスク．

■テストライブラリ
  代替API，ターゲット依存API，ターゲット依存マクロの総称．

■代替API
  カーネルに用意されているカーネルオブジェクトの状態を参照する
  APIの代わりに用いるTTGの独自関数．

■ターゲット依存API
  任意のタイミングで割込みを発生させたり，時間を制御するために必要な
  ターゲット毎に実装が必要となる関数．

■ターゲット依存マクロ
  割込み番号やCPU例外ハンドラ番号など，テストプログラムで使用するターゲ
  ットに依存した値を定義する必要のあるマクロ．

■TOPPERS Test Suite Package (TTSP)
  TTGを始めとしたTOPPERS新世代カーネルを対象としたテストスイートの総称．

■APIテスト
  TTSPに含まれるAPIに着目したテスト．

■バリエーション
  FMPカーネルにおいては，プロセッサ数やタイマ方式などのターゲットシステ
  ムのハードウェアアーキテクチャの違いにより，入力されたTESRYデータの実
  施可否が異なる．このハードウェアアーキテクチャの違い(組み合わせ)をバ
  リエーションと呼ぶ．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(2) 概要
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TTGは，TOPPERSプロジェクトから開発・公開されているシングルプロセッサ対
応OSであるTOPPERS/ASPカーネル(以下，ASPカーネル)と，マルチプロセッサ対
応OSであるTOPPERS/FMPカーネル(以下，FMPカーネル)に対する，APIテスト用の
テストプログラムを生成するツールである．TESRY記法によって記述されたテス
トシナリオを読み込み，1つのテストプログラムとして生成する．

----------------------------------------------------------------------
(2.1) TESRYデータの概要
----------------------------------------------------------------------
TESRYデータでは，1つのテストシナリオを以下の3つの部分に分けて記述する．

(2.1.1) pre_condition (前状態)
テストを行うAPIを呼び出すときのシステムの状態を記述する．

(2.1.2) do (テスト内容)
テスト対象のAPIが実行される処理単位や，その戻り値などを記述する．

(2.1.3) post_condition(後状態)
テスト対象のAPIを実行した結果のシステムの状態を記述する．

なお，上記の記述以外にも複雑な記述方法も可能である．詳細は，
tesry_spec.txtを参照する．

----------------------------------------------------------------------
(2.2) 生成されるテストプログラムの概要
----------------------------------------------------------------------
テストプログラムでは，管理タスクのみ初期起動し，テストに登場する処理単
位は，管理タスクからの操作により，テストシナリオに合わせて起動する．
テストプログラムの主な流れは以下のとおりである．

・pre_conditionで定義したシステムの状態に移行する
・pre_conditionを満たしていることをチェックする
・doで定義したAPIを実行する
・post_conditionを満たしていることをチェックする
・システムを初期状態に移行する

----------------------------------------------------------------------
(2.3) テストプログラムでチェックする内容
----------------------------------------------------------------------
・doを実行する前に正しくpre_conditionで定義した状態を満たしているか
・doを実行した後に正しくpost_conditionで定義した状態を満たしているか
・doおよびpost_conditionが想定した順序で処理が行われているか(チェックポイント)
・テストプログラム内で呼び出されるAPIが全て正しい戻り値であるか

以上の点をチェックして1つでもエラーがあれば，エラー内容を出力し，カーネ
ルを終了する．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(3) 動作環境
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
(3.1) TTGの実行環境
----------------------------------------------------------------------
TTGはRubyによって記述されているため，Rubyの実行環境が必要である．Rubyの
対応バージョンは1.8.7である．

----------------------------------------------------------------------
(3.2) 生成するテストプログラムの対応カーネル
----------------------------------------------------------------------
TTGは，ASPカーネル，FMPカーネル上で動作するテストプログラムを生成する．

動作確認は以下のバージョンにおけるat91skyeye_gcc依存部を使用した．
・ASPカーネル 1.7.0，http://www.toppers.jp/asp-kernel.html
・FMPカーネル 1.2.1，http://www.toppers.jp/fmp-kernel.html

使用したSkyEyeは以下のバージョンである．
・skyeye_devm_package-1.0.5，http://www.toppers.jp/sim.html

----------------------------------------------------------------------
(3.3) ビルドに必要なテストライブラリ
----------------------------------------------------------------------
TTGで生成したテストプログラムをビルドするには，テストライブラリが必要で
ある．テストライブラリのうち，代替APIはターゲットに依存せず，TTSPに用意
されているため，これを使用する．ターゲット依存API，ターゲット依存マクロ
はターゲット毎に実装が必要であるが，at91skyeye_gcc依存部をはじめとして，
いくつかのターゲット依存部は，TTSP内に用意されているため，新規ターゲッ
トにポーティングする際は，参考にする．テストライブラリを用意したら，(4
)章を参考にテストプログラムとのリンク設定を行う．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(4) テストライブラリへのリンク
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
本節では，テストライブラリへのリンク方法について記述する．
※TTBを使用する場合のリンク方法については，TTSPのユーザーズマニュアルの
  (4.4.2)節の(b)を参照する

----------------------------------------------------------------------
(4.1) 代替API
----------------------------------------------------------------------
[ファイル名] ttsp_test_lib.c
             ttsp_test_lib.h

代替APIはTTSP内にASPカーネル用，FMPカーネル用がそれぞれ用意されており，
ターゲットに依存せずに使用できるため，ポーティングは不要である．
(ファイルへのパスは，TTSPのユーザーズマニュアルを参照する)

テストプログラムのビルドに用いるMakefileへ以下の記述を追加する．

・アプリケーションプログラムへttsp_test_lib.oを追加
  例) APPL_COBJS = $(APPLNAME).o ttsp_test_lib.o

・ttsp_test_lib.c，ttsp_test_lib.hが配置されているディレクトリへのパス
  をアプリケーションのディレクトリ名に登録
  例) APPLDIR = $(SRCDIR)/ttsp/library/ASP/test

なお，USE_TSKINICTXBを定義しているターゲットでは，代替APIの実装が異なり，
タスクのスタック領域のサイズおよび先頭番地を取得するターゲット依存APIが
必要となる．ASPカーネルの場合は(5.7)(5.8)節，FMPカーネルの場合は，
(6.8)(6.9)節のターゲット依存APIを実装する．

----------------------------------------------------------------------
(4.2) ターゲット依存API
----------------------------------------------------------------------
[ファイル名] (必須)ttsp_target_test.h

ターゲット依存APIはターゲット毎に実装が必要である．また，TTGが生成する
テストプログラムのhファイルで，ttsp_target_test.hをincludeするため，
ttsp_target_test.hから参照可能なファイルに実装する必要がある．後述のタ
ーゲット依存APIの仕様を満たしていれば，実装するファイルパスやファイル名
は任意である．また，処理を割込み禁止にしてから実行するような配慮も必要
ない．

テストプログラムのビルドに用いるMakefileのターゲット依存部
(Makefile.targetなど)へ以下の記述を追加する．

・カーネルプログラムへttsp_target_test.oや実装したファイルを追加
  例) KERNEL_COBJS := $(KERNEL_COBJS) target_config.o target_timer.o ttsp_target_test.o

テストプログラムのビルドに用いるMakefileへ以下の記述を追加する．

・ttsp_target_test.c，ttsp_target_test.hや実装したファイルが配置されて
  いるディレクトリへのパスをアプリケーションのディレクトリ名に登録
  例) APPLDIR = $(SRCDIR)/ttsp/library/ASP/target/at91skyeye_gcc

----------------------------------------------------------------------
(4.3) ターゲット依存マクロ
----------------------------------------------------------------------
[ファイル名] (必須)ttsp_target_test.h

ターゲット依存マクロはターゲット毎に定義が必要である．また，TTGが生成す
るテストプログラムのhファイルで，ttsp_target_test.hをincludeするため，
ttsp_target_test.hから参照可能なファイルに定義する必要がある．

定義が必要なマクロは，TTSP内に用意されているat91skyeye_gcc依存部の
ttsp_target_test.hに定義された"TTSP_"から始まるマクロである．

ターゲット依存APIと合わせてテストプログラムへリンクする．

※割込み番号やCPU例外ハンドラ番号等が必要なだけ用意できない場合は，
  (8.1)節を参照する．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(5) ASPカーネル用のターゲット依存APIの仕様
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ターゲット依存APIは，以下の仕様を満たす形で実装する．
※ターゲット依存APIの実装が困難な場合，(8.3)節を参照する．

----------------------------------------------------------------------
(5.1) void ttsp_target_stop_tick(void)
----------------------------------------------------------------------
・システム時刻の更新を停止する．
・システム時刻の更新が停止されれば，実現方法は任意である．
・実装方法の例は以下である．
  ・タイマ割込みを発生させない
  ・タイマ割込みハンドラのシステム時刻更新処理を実行しない

----------------------------------------------------------------------
(5.2) void ttsp_target_start_tick(void)
----------------------------------------------------------------------
・ttsp_target_stop_tickで停止していたシステム時刻の更新を再開する．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．

----------------------------------------------------------------------
(5.3) void ttsp_target_gain_tick(void)
----------------------------------------------------------------------
・システム時刻を1ミリ秒更新する．
・テストプログラムでは，本関数を実行することにより，システム時刻が更新
  されたことを確認してから処理を進めるため，本関数内でシステム時刻の更
  新や，タイムイベントハンドラの起動を待つ必要はない．逆に，待つ実装と
  しても支障はない．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．

----------------------------------------------------------------------
(5.4) void ttsp_int_raise(INTNO intno)
----------------------------------------------------------------------
・intnoで指定した割込み番号の割込みを発生させる．
・テストプログラムでは，本関数を実行した後に，割込みハンドラもしくは割
  込みサービスルーチンが起動することを確認してから処理を進めるため，本
  関数内で割込みが実際に発生することを待つ必要はない．逆に，待つ実装と
  してはならない．これは多重割込みのテスト等で，高優先度の割込みハンド
  ラから低優先度の割込みを発生させた際に，処理が停止するのを防ぐためで
  ある．

----------------------------------------------------------------------
(5.5) void ttsp_clear_int_req(INTNO intno)
----------------------------------------------------------------------
・intnoで指定した割込み発生時に，明示的に割込み要求をクリアする．
・割込みコントローラ上の割込み要求フラグクリアは，i_begin_intと
  i_end_intによりカーネルが行うが，ターゲットシステムによっては，タイマ
  やシリアルなど，個々のデバイスに対する割込み要求のクリア処理が必要と
  なる場合がある．このクリア処理を実装する．
・本処理が不要なターゲットシステムの場合，何も処理しない空の
  ttsp_clear_int_reqを定義する．
・テストプログラムでは，割込みハンドラ，および割込みサービスルーチンの
  先頭で本関数を実行する．同一割り込み番号に複数の割込みサービスルーチ
  ンが登録されている場合，すべての割込みサービスルーチンの先頭で本関数
  を実行する．

----------------------------------------------------------------------
(5.6) void ttsp_cpuexc_raise(EXCNO excno)
----------------------------------------------------------------------
・excnoで指定したCPU例外ハンドラ番号に対するCPU例外を発生させる．
・テストプログラムでは，本関数を実行することにより，CPU例外ハンドラが起
  動することを確認してから処理を進めるため，本関数内でCPU例外が実際に発
  生することを待つ必要はない．逆に，待つ実装としても支障はない．
・テストプログラムでは，CPU例外が発生し，CPU例外ハンドラが起動した後，
  発生元のコンテキストにリターンする前提で処理を進めるため，発行元のコ
  ンテキストにリターン可能なCPU例外を発生させる．
・発生元のコンテキストにリターンできない場合，ttsp_cpuexc_hookを使用す
  る．
・ttsp_cpuexc_hookを使用しても，発生元のコンテキストにリターンできない
  ターゲットは，CPU例外を使用するテストが実施できないため，TTG環境設定
  ファイルにて，CPU例外発生関数を無しに設定する．

----------------------------------------------------------------------
(5.7) void ttsp_cpuexc_hook(EXCNO excno, void* p_excinf)
----------------------------------------------------------------------
・CPU例外ハンドラからの戻り番地の設定など，CPU例外発生元のコンテキスト
  にリターンするために必要な処理等を実行する．
・excnoにはCPU例外ハンドラ番号が，p_excinfにはCPU例外の情報を記憶してい
  るメモリ領域の先頭番地(CPU例外ハンドラの引数)が渡される．
・本処理が不要なターゲットシステムの場合，何も処理しない空の
  ttsp_cpuexc_hookを定義する．
・テストプログラムでは，CPU例外ハンドラの先頭で本関数を実行する．

----------------------------------------------------------------------
(5.8) SIZE ttsp_target_get_stksz(TINIB *p_tinib)
----------------------------------------------------------------------
・USE_TSKINICTXBを定義しているターゲットのみ必要．
・p_tinibで指定したタスク初期化ブロック構造体から，タスクのスタック領域
  のサイズを返す．

----------------------------------------------------------------------
(5.9) void* ttsp_target_get_stk(TINIB *p_tinib)
----------------------------------------------------------------------
・USE_TSKINICTXBを定義しているターゲットのみ必要．
・p_tinibで指定したタスク初期化ブロック構造体から，タスクのスタック領域
  の先頭番地を返す．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(6) FMPカーネル用のターゲット依存APIの仕様
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下に仕様を示す関数を，ターゲット依存APIとして実装する．
※ターゲット依存APIの実装が困難な場合，(8.3)節を参照する．

----------------------------------------------------------------------
(6.1) void ttsp_target_stop_tick(void)
----------------------------------------------------------------------
＜ローカルタイマ方式＞
・全プロセッサのシステム時刻の更新を停止する．
・全プロセッサのシステム時刻の更新が停止されれば，実現方法は任意である．
・全プロセッサのシステム時刻の更新は同時に停止する必要はなく，本関数か
  らリターンした時点で，全プロセッサのシステム時刻の更新が停止していれ
  ばよい．
・実装方法の例は以下である．
  ・全プロセッサのタイマ割込みを発生させない
  ・全プロセッサのタイマ割込みハンドラのシステム時刻更新処理を実行しな
    い

＜グローバルタイマ方式＞
・システム時刻管理プロセッサのシステム時刻の更新を停止する．
・システム時刻管理プロセッサのシステム時刻の更新が停止されれば，実現方
  法は任意である．
・実装方法の例は以下である．
  ・システム時刻管理プロセッサのタイマ割込みを発生させない
  ・システム時刻管理プロセッサのタイマ割込みハンドラのシステム時刻更新
    処理を実行しない

----------------------------------------------------------------------
(6.2) void ttsp_target_start_tick(void)
----------------------------------------------------------------------
＜ローカルタイマ方式＞
・ttsp_target_stop_tickで停止していた全プロセッサのシステム時刻の更新を
  再開する．
・全プロセッサのシステム時刻の更新は同時に再開する必要はなく，本関数か
  らリターンした時点で，全プロセッサのシステム時刻の更新が再開していれ
  ばよい．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．

＜グローバルタイマ方式＞
・ttsp_target_stop_tickで停止していたシステム時刻管理プロセッサのシステ
  ム時刻の更新を再開する．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．

----------------------------------------------------------------------
(6.3) void ttsp_target_gain_tick_pe(ID prcid, bool_t wait_flg)
----------------------------------------------------------------------
＜ローカルタイマ方式/グローバルタイマ方式＞
・prcidで指定したプロセッサのシステム時刻を1ミリ秒更新する．
・wait_flgをtrueとした場合，システム時刻が更新されるまで本関数の中で待
  つ．
・wait_flgをfalseとした場合，システム時刻が更新されるのを待たずにリター
  ンする．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．
・グローバルタイマ方式では，configure.yamlで指定したシステム時刻管理プ
  ロセッサを，prcidに指定して使用する．

----------------------------------------------------------------------
(6.4) void ttsp_target_gain_tick(void)
----------------------------------------------------------------------
＜ローカルタイマ方式＞
・全プロセッサのシステム時刻を1ミリ秒更新する．
・全プロセッサのシステム時刻が更新されるまで本関数の中で待つ．
・テストプログラムでは，タイムイベントハンドラの起動には使用しない．
・テストプログラムでは，ttsp_target_stop_tickでシステム時刻を停止した状
  態でのみ発行される．

＜グローバルタイマ方式＞
・本関数は使用しないため，実装は不要である．

----------------------------------------------------------------------
(6.5) void ttsp_int_raise(INTNO intno)
----------------------------------------------------------------------
・intnoで指定した割込み番号の割込みを発生させる．
・テストプログラムでは，本関数を実行することにより，割込みハンドラもし
  くは割込みサービスルーチンが起動することを確認してから処理を進めるた
  め，本関数内で割込みが実際に発生することを待つ必要はない．逆に，待つ
  実装としてはならない．これは多重割込みのテスト等で，高優先度の割込み
  ハンドラから低優先度の割込みを発生させた際に，処理が停止するのを防ぐ
  ためである．

----------------------------------------------------------------------
(6.6) void ttsp_clear_int_req(INTNO intno)
----------------------------------------------------------------------
・intnoで指定した割込み発生時に，明示的に割込み要求をクリアする．
・割込みコントローラ上の割込み要求フラグクリアは，i_begin_intと
  i_end_intによりカーネルが行うが，ターゲットシステムによっては，タイマ
  やシリアルなど，個々のデバイスに対する割込み要求のクリア処理が必要と
  なる場合がある．このクリア処理を実装する．
・本処理が不要なターゲットシステムの場合，後述のconfigure.yamlの設定に
  より，本関数を発行しないテストプログラムとすることが可能である．
・テストプログラムでは，割込みハンドラ，および割込みサービスルーチンの
  先頭で本関数を実行する．同一割り込み番号に複数の割込みサービスルーチ
  ンが登録されている場合，すべての割込みサービスルーチンの先頭で本関数
  を実行する．

----------------------------------------------------------------------
(6.7) void ttsp_cpuexc_raise(EXCNO excno)
----------------------------------------------------------------------
・excnoで指定したCPU例外ハンドラ番号に対するCPU例外を発生させる．
・テストプログラムでは，本関数を実行することにより，CPU例外ハンドラが起
  動することを確認してから処理を進めるため，本関数内でCPU例外が実際に発
  生することを待つ必要はない．逆に，待つ実装としても支障はない．
・テストプログラムでは，CPU例外が発生し，CPU例外ハンドラが起動した後，
  発生元のコンテキストにリターンする前提で処理を進めるため，発行元のコ
  ンテキストにリターン可能なCPU例外を発生させる．
・発生元のコンテキストにリターンできない場合，ttsp_cpuexc_hookを使用す
  る．
・ttsp_cpuexc_hookを使用しても，発生元のコンテキストにリターンできない
  ターゲットは，CPU例外を使用するテストが実施できないため，TTG環境設定
  ファイルにて，CPU例外発生関数を無しに設定する．

----------------------------------------------------------------------
(6.8) void ttsp_cpuexc_hook(EXCNO excno, void* p_excinf)
----------------------------------------------------------------------
・CPU例外ハンドラからの戻り番地の設定など，CPU例外発生元のコンテキスト
  にリターンするために必要な処理等を実行する．
・excnoにはCPU例外ハンドラ番号が，p_excinfにはCPU例外の情報を記憶してい
  るメモリ領域の先頭番地(CPU例外ハンドラの引数)が渡される．
・本処理が不要なターゲットシステムの場合，何も処理しない空の
  ttsp_cpuexc_hookを定義する．
・テストプログラムでは，CPU例外ハンドラの先頭で本関数を実行する．

----------------------------------------------------------------------
(6.9) SIZE ttsp_target_get_stksz(TINIB *p_tinib)
----------------------------------------------------------------------
・USE_TSKINICTXBを定義しているターゲットのみ必要．
・p_tinibで指定したタスク初期化ブロック構造体から，タスクのスタック領域
  のサイズを返す．

----------------------------------------------------------------------
(6.10) void* ttsp_target_get_stk(TINIB *p_tinib)
----------------------------------------------------------------------
・USE_TSKINICTXBを定義しているターゲットのみ必要．
・p_tinibで指定したタスク初期化ブロック構造体から，タスクのスタック領域
  の先頭番地を返す．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(7) TTGによるテスト実施手順
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
(7.1) TTG設定ファイル(configure.yaml)
----------------------------------------------------------------------
TTGの各種設定は，configure.yamlの内容を変更することで行う．
configure.yaml内に各設定項目の説明を付与しているので，configure.yamlを
参照する．configure.yaml設定時の注意事項は(8)章を参照する．

なお，macro以下に定義している値は，TTGに入力したTESRYデータ内に記述され
た文字列を変換するために使用するマクロである．例えば，TESRYデータに，
prcid: PRC_SELFと記述されていて，configure.yamlにPRC_SELF: 1と定義され
ていた場合，TASK1のprcidを1へ変換したテストプログラムを生成する．これに
より，configure.yamlのマクロの値を変更して，テストプログラムを再度生成
することで，様々な値でテストが実施可能となる．

----------------------------------------------------------------------
(7.2) テストプログラム生成
----------------------------------------------------------------------
TTG(ttg.rb)にTESRYデータ(YAML)を引数として渡し実行することで，カレント
フォルダにout.c，out.h，out.cfgの3ファイルを生成する．このとき，対象カ
ーネルを表す以下のオプションが必須となる．
・ASPカーネル: -a
・FMPカーネル: -f

例) ASPカーネルを対象としたinput.yamlのテストプログラム生成
  $ ./ttg.rb -a input.yaml

また，複数のTESRYデータを引数に並べて指定すると(ワイルドカードでの指定
でも可)，それらのTESRYデータをすべて含んだテストプログラムを生成する．

  $ ./ttg.rb -a */*.yaml

その他のオプションについては(9)章を参照する．

----------------------------------------------------------------------
(7.3) TTG実行時のエラー表示
----------------------------------------------------------------------
指定したTESRYデータが存在しない場合や，オプションの指定が不正な場合など，
TTG実行時に何らかの問題が発生した場合，エラーメッセージを出力する．例え
ば，ファイルが存在しない場合には以下のように出力する．

======================================================================
Some errors occurred.
======================================================================
* /asp/ttsp/api_test/ASP/task_manage/act_tsk/act_tsk_b-.yaml
  1. can't open file. [/asp/ttsp/api_test/ASP/task_manage/act_tsk/act_tsk_b-.yaml]
======================================================================
1 test cases error.

TTGでは，内部モジュールであるTTCによってTESRYデータの正当性検証を行う．
TESRYデータに誤りがあった場合に，例えば以下のようなエラーメッセージを出
力する．
(act_tsk_b-1.yamlのpre_conditionにおいて実行中の処理単位が存在しない)

======================================================================
Some errors occurred.
======================================================================
* /asp/ttsp/api_test/ASP/task_manage/act_tsk/act_tsk_b-1.yaml
  1. [/ASP_task_manage_act_tsk_b_1/pre_condition]
  => T4_001: no running process unit exist.
======================================================================
1 test cases error.

T4_001はエラーコードである．チェック項目の一覧についてはcheck_list.txt
を参照する．

----------------------------------------------------------------------
(7.4) バリエーション判別
----------------------------------------------------------------------
複数のTESRYデータをまとめて読み込んだ場合は，オプションおよび
configure.yamlで設定されたバリエーションと，入力されたTESRYデータのテス
トシナリオで必要となるバリエーションとを比較して，実行可能なTESRYデータ
のみを採用したテストプログラムを生成する．この際，除外されたファイルの
一覧をttg_exclusion_list.txtとしてカレントフォルダに出力する．また，バ
リエーション判別によって除外されたTESRYデータが存在することを示す以下の
ようなメッセージを出力する．
※バリエーション判別の詳細はvariation.txtを参照する．

======================================================================
Some files are excluded by variation mismatch.
======================================================================
* timer architecture (configure: local)[global]  6 test cases
======================================================================
6 test cases are excluded.(98% passed, 590 / 596 test cases)

全ての入力ファイルが除外された場合は，続けて，通常のエラーと同様のヘッ
ダ(Some errors occurred.)で，以下のようなエラーが出力される．

======================================================================
Some errors occurred.
======================================================================
available test scenario does not exist.

----------------------------------------------------------------------
(7.5) 実行モジュールの作成
----------------------------------------------------------------------
(4)章で述べたテストライブラリの設定をしたMakefileを，TTGが生成したテス
トプログラムが存在するカレントフォルダに配置し，以下のコマンドを実行し，
テストプログラムのビルドを行う．

$ make depend
$ make

----------------------------------------------------------------------
(7.6) テスト実行
----------------------------------------------------------------------
作成された実行モジュールをターゲットシステムで実行する．

----------------------------------------------------------------------
(7.7) テスト実行結果の確認
----------------------------------------------------------------------
TTGが生成するテストプログラムでは，syslog関数により実行状況を出力する．
すべてのシステム状態のチェックに問題がなく，想定した順序で動作した場合，
下記のように「All check points passed.」が出力される．1つでも問題が発生
すると，エラーを出力してカーネルを終了する．

(テストID) start.
Check point 1 passed.
  ・
  ・
  ・
Check point (n) passed.
All check points passed.

以下に，主なエラー発生例をいくつか示す．

チェックポイントが想定した順序通りに通過しなかった場合(例：1の次に3にい
ってしまった場合)は，以下のように出力されて終了する．

test1 start.
Check point 1 passed.
## Unexpected check point 3.

APIが予期しないエラーコード(例：E_OBJ)を返した場合には，以下のように出
力される．

test1 start.
Check point 1 passed.
Check point 2 passed.
Check point 3 passed.
Check point 4 passed.
## Unexpected error E_OBJ detected at out.c:72.

アサートによるシステム状態のチェックがfalseになった場合には，以下のよう
に出力される．

test1 start.
Check point 1 passed.
Check point 2 passed.
## Assertion `rtsk.wupcnt == 1' failed at out.c:109.

タイムアウトを伴う処理においてタイムアウトが発生した場合，以下のように
出力される．(例：1回目のバリア同期で，プロセッサ1がプロセッサ2を待って
タイムアウトした場合)

## PE 1 : ttsp_barrier_sync(phase:3) caused a timeout to wait for PE 2
## in "ttsp_barrier_sync(3, 2)".

バリア同期のリエントラントが発生した場合には，以下のように出力される．

## PE 1 : ttsp_barrier_sync has re-entranted
## in ttsp_barrier_sync(3, 2)".

※タイムアウト時間はターゲット依存マクロで定義している．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(8) configure.yaml設定時の注意事項
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
(8.1) ターゲット依存マクロの定義に関して
----------------------------------------------------------------------
想定するTESRYデータでは，割込み優先度に，割込みハンドラ用の高/中/低，割
込みサービスルーチン用の高/中/低を設定するため，以下のように合計6個の割
込み番号に対するTESRYデータ変換マクロを用意している．

INTNO_SELF_INH_A: TTSP_INTNO_A
INTNO_SELF_INH_B: TTSP_INTNO_B
INTNO_SELF_INH_C: TTSP_INTNO_C
INTNO_SELF_ISR_A: TTSP_INTNO_D
INTNO_SELF_ISR_B: TTSP_INTNO_E
INTNO_SELF_ISR_C: TTSP_INTNO_F

これに対し，ターゲット依存マクロでもTTSP_INTNO_A〜TTSP_INTNO_Fの6個の割
込み番号を用意する必要がある．例えば，at91skyeye_gccでは以下のように設
定されている．

#define TTSP_INTNO_A    9	/* 割込み番号A */
#define TTSP_INTNO_B   10	/* 割込み番号B */
#define TTSP_INTNO_C   11	/* 割込み番号C */
#define TTSP_INTNO_D   12	/* 割込み番号D */
#define TTSP_INTNO_E   13	/* 割込み番号E */
#define TTSP_INTNO_F   14	/* 割込み番号F */

しかし，ターゲットシステムによっては，割込み番号を6個用意することが難し
い場合がある．この場合，複数回に分けてテストプログラムを生成することで，
テストを実施する．例えば，割込み番号が3個しか用意できない場合に，ターゲ
ット依存マクロは，以下のように3個だけ定義する．

/*  
 *  割込み番号(正常値)
 */
#define TTSP_INTNO_A    9	/* 割込み番号A */
#define TTSP_INTNO_B   10	/* 割込み番号B */
#define TTSP_INTNO_C   11	/* 割込み番号C */

configure.yamlでは，以下のようにターゲット依存マクロで用意した割込み番
号のみ記述する．

INTNO_SELF_INH_A: TTSP_INTNO_A
INTNO_SELF_INH_B: TTSP_INTNO_B
INTNO_SELF_INH_C: TTSP_INTNO_C
INTNO_SELF_ISR_A: TTSP_INTNO_A
INTNO_SELF_ISR_B: TTSP_INTNO_B
INTNO_SELF_ISR_C: TTSP_INTNO_C

上記の設定で，複数のTESRYデータを入力してTTGを実行し，以下のエラーが表
示された場合，TESRYデータ内で定義しているテストIDの
"ASP_interrupt_ena_int_d_1"と"ASP_staticAPI_ATT_ISR_d"において，割込み
番号TTSP_INTNO_Aを，割込みハンドラ(INTHDR)と割込みサービスルーチン(ISR
)の両方で使用していることで，1つのテストプログラムとしてマージできない
ことを示している．

======================================================================
Some errors occurred.
======================================================================
T7_005: "intno" "TTSP_INTNO_A" of "INTHDR" and "ISR" is conflict.
 INTHDR
 * ASP_interrupt_ena_int_d_1
 ISR
 * ASP_staticAPI_ATT_ISR_d

この場合，"ASP_interrupt_ena_int_d_1"か"ASP_staticAPI_ATT_ISR_d"のどち
らかを入力するTESRYデータから除外して，別々にテストプログラムを生成する
ことで，両方のテストを実施する．

----------------------------------------------------------------------
(8.2) ターゲット依存APIの実装に関して
----------------------------------------------------------------------
(5)章，(6)章のターゲット依存APIが用意できない場合，configure.yamlの設定
により，入力されたTESRYデータの中から，ターゲット依存APIを必要としない
TESRYデータだけを対象としたテストプログラムを生成することが可能である．
ターゲット依存APIは以下の3つに分類されるため，それぞれの関数の有無を
configure.yamlで設定する．TESRYデータを取捨選択することから，ターゲット
依存APIの有無もバリエーションの1つとみなし，ターゲット依存APIの有無によ
りTESRYデータが除外された場合，以下のように除外した要因と，件数を表示す
る．

======================================================================
Some files are excluded by variation mismatch.
======================================================================
* can't stop time  4 test cases
======================================================================
4 test cases are excluded.(80% passed, 16 / 20 test cases)

3つに分類したターゲット依存APIの有無の設定は以下である．

(8.2.1) システム時刻制御関数
func_timeをfalseとすることで，以下の関数を必要とするTESRYデータを除外す
る．システム時刻制御関数が無い場合，時間を制御するテストシナリオは一切
実施できないため，時間制御の要否を設定するパラメータである
all_gain_timeをtrueにする必要がある．
※詳細はvariation.txtを参照する．

＜ASPカーネル＞
・(5.1) void ttsp_target_stop_tick(void)
・(5.2) void ttsp_target_start_tick(void)
・(5.3) void ttsp_target_gain_tick(void)

＜FMPカーネル＞
・(6.1) void ttsp_target_stop_tick(void)
・(6.2) void ttsp_target_start_tick(void)
・(6.3) void ttsp_target_gain_tick_pe(ID prcid, bool_t wait_flg)
・(6.4) void ttsp_target_gain_tick(void)

(8.2.2) 割込み発生関数
func_interruptをfalseとすることで，以下の関数を必要とするTESRYデータを
除外する．

＜ASPカーネル＞
・(5.4) void ttsp_int_raise(INTNO intno)
・(5.5) void ttsp_clear_int_req(INTNO intno)

＜FMPカーネル＞
・(6.5) void ttsp_int_raise(INTNO intno)
・(6.6) void ttsp_clear_int_req(INTNO intno)

(8.2.3) CPU例外発生関数
func_exceptionをfalseとすることで，以下の関数を必要とするTESRYデータを
除外する．

＜ASPカーネル＞
・(5.6) void ttsp_cpuexc_raise(EXCNO excno)

＜FMPカーネル＞
・(6.7) void ttsp_cpuexc_raise(EXCNO excno)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(9) 実行時オプション
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
コマンドラインで以下の様式に沿って引数を与える．

./ttg.rb {-a|-f} [options] {file or directory}

----------------------------------------------------------------------
(9.1) 標準オプション
----------------------------------------------------------------------
 short |    long   |         説明
-------------------------------------------
 -v    | --version | バージョン情報
 -h    | --help    | ヘルプ

----------------------------------------------------------------------
(9.2) プロファイル選択(いずれか必須)
----------------------------------------------------------------------
 option |         説明
-------------------------------------------
 -a     | 入力するTESRYデータがASP
 -f     | 入力するTESRYデータがFMP

----------------------------------------------------------------------
(9.3) TTGオプション
----------------------------------------------------------------------
    option    |            説明               |             デフォルト値
----------------------------------------------------------------------------------------
 -c CONF_FILE | 読み込むconfigureファイル指定 | TOOL_ROOT/ttg/bin/configure.yaml
 -t           | テストプログラムフロー出力on  | off
 -d           | デバッグモードon              | off
 -p           | プログレスバー表示off         | on
 -j           | TTJ出力on                     | off

TTGのデバッグモードでは，以下の3つのファイルを出力する．

(a) ttg_before.yaml
TTGが読み込んだTESRYデータを，1つのTESRYデータにまとめたファイル．

(b) ttg_after.yaml
TTGが読み込み，以下に挙げる前処理を行った後のファイル．
 - TESRYデータの補完処理
 - マクロ置換処理
 - テストシナリオID付与による，オブジェクトIDや変数名の一意化処理
ttg_before.yamlと比較することにより，上記処理で実施した内容を確認するた
めのファイルである．

(c) ttg_global.yaml
TTGは，グローバルタイマ方式において，(11.6)節で述べる置換処理を行う．
ttg_after.yamlと比較することにより，置換処理で実施した内容を確認するた
めのファイルである．

----------------------------------------------------------------------
(9.4) ロングオプションによるconfigure.yaml設定値の上書き
----------------------------------------------------------------------
ロングオプションによってconfigure.yamlに設定するパラメータ名を直接指定
し，値を設定する．configure.yamlに設定した値は上書きされる．

例)スタックサイズを1024に変更する場合
  --stack_size 1024

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(10) GCOV機能
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
GCOVは，ASPカーネルおよびFMPカーネルのat91skyeye_gcc依存部でサポートさ
れているプログラムのソースコードカバレッジを取得するツールである．
configure.yamlもしくは実行時オプションにてGCOV取得をONにした場合，生成
するテストプログラムにGCOV取得用のコードを追加する．GCOV取得を行うため
に，at91skyeye_gccのtarget_config.cに用意されたGCOV取得用ライブラリを利
用する．

GCOV初期化
・gcov_init()

GCOV取得中断
・gcov_pause()

GCOV取得再開
・gcov_resume()

GCOV出力
・gcov_dump()

これらの関数を用いて，doの前後のみのカバレッジ取得を可能としている．ま
た，variationにgcov_all:trueを指定することで，テストシナリオ全体のGCOV
取得を行うこともできる．

なお，gcov_resumeとgcov_pauseは交互に呼び出されることを想定するため，
TTGが生成するFMPカーネル用のテストプログラムには，ttg_gcov_resumeと
ttg_gcov_pauseに排他制御機構が定義される．

(a)ttg_gcov_resume
gcov_resumeの呼び出し時にロックを取得する．ロックを取得できなければ，
ループによって待つ．

(b)ttg_gcov_pause
gcov_pauseの呼び出し時にロックを解放する．ロックが取得されていなければ，
以下のようなエラーを出力する．

PE 1 : Check point : 1 passed.
PE 1 : Check point : 2 passed.
## gcov_lock_flg hadn't be locked. [ttg_gcov_pause]

GCOV関連ファイルの取り扱いについてはカーネルパッケージに付属している
at91skyeye_gcc依存部のtarget_user.txtを参照する．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(11) テストプログラムに関する特記事項
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
本章では，TTG利用者が，TTGが生成したテストプログラムを確認した際に，疑
問を抱く可能性のある処理について，説明する．

----------------------------------------------------------------------
(11.1) 全TESRYデータを跨って使用する処理単位
----------------------------------------------------------------------
タスクやセマフォなどのオブジェクトは，入力されたTESRYデータに記述された
数だけ定義する．しかし，割込みハンドラは，1つの割込み番号に対して1つし
か定義できないため，複数のTESRYデータにおいて同一割込み番号が使用されて
いると，テストプログラムをマージすることができない．そこで，同一割込み
番号に対する割込みハンドラは，全TESRYデータに対して1つのみ定義し，その
割込み番号に関連付けた関数を使い回すことで割込み番号を共有する．具体的
には，以下のように2つのTESRYデータをマージした場合，if文によって実行中
のTESRYデータに対応する処理だけが実行されるような関数とする．

<tesry_a.yaml>
  INH1:
    intno: TTSP_INTNO_A

<tesry_b.yaml>
  INH2:
    intno: TTSP_INTNO_A

<テストプログラム>
void ttg_inthdr_ttsp_intno_a(void){
	if (TTG_INTHDR_TTSP_INTNO_A_bootcnt == tesry_a) {
		ttsp_check_point(1);
			:
	}

	if (TTG_INTHDR_TTSP_INTNO_A_bootcnt == tesry_b) {
		ttsp_check_point(5);
			:
	}
}

以上の仕様を実現するため，同一割込み番号に対する割込みハンドラにおいて，
属性や割込み優先度などの設定値が異なるTESRYデータが存在する場合，cfgフ
ァイルに定義する値が決定できないため，エラーを表示する．割込み処理ルー
チン，CPU例外ハンドラについても同様の処理を行う．

なお，タスクやセマフォなどのオブジェクトは，TESRYデータ内に記述したテス
トIDと各オブジェクトIDを"_"で繋いだIDとして，複数のテストをマージしても
ユニークとなるようにリネーム処理を行うが，割込みハンドラ，割込みサービ
スルーチン，CPU例外ハンドラに関しては，以下の命名規則でリネームを行う．

■割込みハンドラ
  TTG_INTHDR + 割込み番号

■割込みサービスルーチン
  TTG_ISR + 割込み番号 + テストID + オブジェクトID

■CPU例外ハンドラ
  TTG_EXCEPTION + CPU例外ハンドラ番号

----------------------------------------------------------------------
(11.2) スピンロックの共有
----------------------------------------------------------------------
スピンロックは，ネイティブ方式の場合，ターゲットシステムによっては，定
義できる数に制限がある．そこで，複数のTESRYデータにおいて，同一クラス内
に登場するスピンロックは1つのみ定義し，全TESRYデータで共有する．そのた
め，スピンロックのオブジェクトIDは，以下の命名規則でリネームを行う．

■スピンロック
  TTG_SPINLOCK + クラス名 + 数値(※)
  ※1から連番に登場する数を付与する

----------------------------------------------------------------------
(11.3) TA_STA属性の周期ハンドラ
----------------------------------------------------------------------
TA_STA属性を指定した周期ハンドラは，カーネル開始と同時に動作を始めるた
め，意図していないタイミングで処理単位が実行される可能性がある．そこで，
TA_STA属性の周期ハンドラは，処理単位の先頭に該当するテストの順番となる
まで，リターンする処理を追加する．また，TA_STA属性が有効であることを確
認するため，カーネル起動直後に，管理タスクから対象周期ハンドラが動作状
態であることを確認する．確認後，対象周期ハンドラを停止して，該当するテ
ストの順番となった際に，再度動作させる．

----------------------------------------------------------------------
(11.4) TA_ENAINT属性の割込みハンドラ，割込み処理ルーチン
----------------------------------------------------------------------
(11.1)節で述べたように，同一割込み番号に対する割込みハンドラは，共有し
た1つの割込みハンドラとするが，TA_ENAINT属性の場合，他のテストシナリオ
に影響を与えないように，カーネル起動直後に管理タスクから割込み禁止とす
る．また，割込み禁止とする前に，TA_ENAINT属性が有効であることを確認する
ために，割込みを発生させ，割込みハンドラが起動することを確認する．割込
み処理ルーチンにおいても同様の処理を行う．

----------------------------------------------------------------------
(11.5) 前状態における割込み優先度マスクの設定
----------------------------------------------------------------------
前状態で指定する割込み優先度マスクは，タスクコンテキストが実行状態の場
合，実行状態の処理単位から設定するが，CPU例外ハンドラ以外の非タスクコン
テキストが実行状態の場合，非タスクコンテキストが起動することで既に割込
み優先度マスクが変更されているため，テストプログラムでは割込み優先度マ
スクの変更は行わない．実行状態の処理単位がCPU例外ハンドラの場合は，CPU
例外を発生させる処理単位において，CPU例外発生前に，割込み優先度マスクを
変更する．

----------------------------------------------------------------------
(11.6) グローバルタイマ方式指定時の置換処理
----------------------------------------------------------------------
FMPカーネルにおいてグローバルタイマ方式を指定した場合，入力されたTESRY
データの内容に応じて，置換処理を行うことがある．例えば，プロセッサ2にタ
イムイベントハンドラが定義されて，システム時刻管理プロセッサがプロセッ
サ1である場合，カーネルの制約によりビルドできない．しかし，タイムイベン
トハンドラがプロセッサ2にしか存在しなければ，プロセッサ1のオブジェクト
と，プロセッサ2のオブジェクトを全て置き換えれば，グローバルタイマ方式に
おいても，等価なテストが実施できる．そこで，TTGではグローバルタイマ方式
において，プロセッサを入れ替えることで，実施可能となるTESRYデータに対し
ては，上記のような置換処理を行う．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(参考) フォルダ構成
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ttg/								TTGモジュール実装部
	bin/							TTG本体，設定ファイル
		builder/					各ビルダークラス
			fmp_builder/			FMP用クラス
				test_scenario/		FMP用テストシナリオクラス
		director/					各ディレクタークラス
		product/					各プロダクトクラス
	common/
		bin/						ASP/FMP共通部
			process_unit/			処理単位クラス
			sc_object/				同期通信オブジェクトクラス
			sys_state/				CPU状態クラス
			test_scenario/			テストシナリオクラス
		doc/						TTG設計ドキュメント
	ttc/							TTCモジュール実装部
		bin/						TTCモジュール
			class/					TTCでのみ使用するクラス
			kwalify/				YAMLライブラリ(※1)
			process_unit/			TTC用処理単位クラス
			sc_object/				TTC用同期通信オブジェクトクラス
			sys_state/				TTC用CPU状態クラス
			test_scenario/			TTC用テストシナリオクラス
		test/						TTCに対するテスト用フォルダ
	ttj/							TTJモジュール実装部
		bin/						TTJモジュール
			class/					TTJでのみ使用するクラス
			test_scenario/			TTJ用テストシナリオクラス
	doc/							各ドキュメント

※1：以下から入手
     http://www.kuwata-lab.com/kwalify/



以上．
