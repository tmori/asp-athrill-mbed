
	APIテスト(TOPPERS/ASPカーネル)の開発および実施要綱

----------------------------------------------------------------------
 TTSP
     TOPPERS Test Suite Package

 Copyright (C) 2009-2011 by Center for Embedded Computing Systems
             Graduate School of Information Science, Nagoya Univ., JAPAN
 Copyright (C) 2009-2011 by Digital Craft Inc.
 Copyright (C) 2009-2011 by NEC Communication Systems, Ltd.
 Copyright (C) 2009-2011 by FUJISOFT INCORPORATED
 Copyright (C) 2009-2010 by Mitsuhiro Matsuura

 上記著作権者は，以下の (1)〜(3) の条件を満たす場合に限り，本ドキュメ
 ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
     および下記の無保証規定が，そのままの形でドキュメント中に含まれて
     いること．
 (2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
     を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
     ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
     りではない．
 (3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
     からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
     本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
     く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

 本ドキュメントは，無保証で提供されているものである．上記著作権者およ
 びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
 る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
 により直接的または間接的に生じたいかなる損害に関しても，その責任を負
 わない．

 $Id: developer.txt 2 2012-05-09 02:23:52Z nces-shigihara $
----------------------------------------------------------------------

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
このドキュメントの位置付け
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
このドキュメントは，APIテストの開発および実施要綱についてまとめたもので
ある．本ドキュメントは，TTSP(TOPPERS Test Suite Package)およびTTG
(TOPPERS Test Generator)のユーザーズマニュアルの記載内容を理解している
ことを前提とする．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
テスト実施概要
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(1)API毎にテスト内容を記述したファイルを用意する．
   このファイルをテストシートと呼ぶ．
   ファイルの配置場所は後述する"フォルダ構成"を参考すること．

(2)テストシートに基づき，テストケース毎に以下の3種類のいずれかの方法で
   テストプログラムを作成する．(それぞれの内容は後述)

   ■オートコードテスト
   ■スクラッチコードテスト(静的API)
   ■コンフィギュレーションエラーテスト(静的API)

(3)作成したテストプログラムを実行する．

(4)skyeyeでgcovによるC1カバレッジを取得して想定したパスを通るか確認する．

※C1カバレッジ: 条件分岐網羅

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
テスト方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
オートコードテスト
----------------------------------------------------------------------
(1)テストケース毎にTESRYデータを作成する．

(2)TTGを使用してTESRYデータからテストプログラムを生成する．

(3)テストプログラムを実行し，エラーが発生しないことを確認する．

----------------------------------------------------------------------
スクラッチコードテスト(静的API)
----------------------------------------------------------------------
(1)静的APIによっては1つのコンフィギュレーションファイルに1つしか定義で
   きないため，TTGによる複数のテストケースのマージができない．そこで，
   TTGを使用せず，スクラッチプログラムで作成する．
   作成するプログラムファイル名は，以下とする．
   out.c
   out.h
   out.cfg

(2)スクラッチで作成したテストプログラムを実施し，テストケースで記載した
   予想結果となることを確認する．

----------------------------------------------------------------------
コンフィギュレーションエラーテスト(静的API)
----------------------------------------------------------------------
(1)静的APIコンフィギュレーションエラーテストは静的APIに不正なパラメータ
   を設定すると意図したエラーが発生することを確認するテストであるため，
   TTGで対応することができない．TTGを使用せず，スクラッチプログラムで作
   成する．
   作成するプログラムファイル名は，以下とする．
   出力されるエラーコードをerr_code.txtに記載する．
   out.c
   out.h
   out.cfg
   err_code.txt

(2)スクラッチで作成したテストプログラムをビルドし，err_code.txtに記載した
   エラーコードが出力されることを確認する．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
テストシート作成要綱
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下の章立てで記述する．

※テストシートの具体的な記述方法，フォーマットについては以下を雛形とし
  て参照すること．
  (A)オートコードテスト                          : snd_pdq
  (B)スクラッチコードテスト(静的API)             : DEF_ICS
  (C)コンフィギュレーションエラーテスト(静的API) : CRE_CYC

※API毎に特筆すべき内容がある場合，備考として説明を追加する．

----------------------------------------------------------------------
0. API仕様
----------------------------------------------------------------------
対象とするバージョンの統合仕様書をSVNからチェックアウトし，各APIの仕様
の部分をそのままコピー＆ペーストする．

----------------------------------------------------------------------
1. 仕様ベースのブラックボックステスト
----------------------------------------------------------------------
1.1 エラー条件のテストケース
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
統合仕様書を基にエラー条件のテストケースを記述する．
エラー条件とは，異常引数や不適当な状態で実行する条件を示す．従って，
E_TMOUT，E_RLWAI，E_DLTは正常な処理であるため，エラー条件ではなく正常条
件として扱うこととする．
テストケース毎に(a)から順にアルファベットで番号を付与し，同一の条件下で
さらに複数の条件が存在する場合は，(a-1)，(a-2)のように番号を付与する．

※ASPカーネル/FMPカーネルでは〔P〕〔D〕の付くエラーコードは返らないため，
  テストの必要はない．
※静的APIでは〔s〕の付くエラーコードは返らないため，テストの必要はない．
※ASPカーネル/FMPカーネルでは，制約タスクをサポートしていないので，
  E_NOSPTが返るテストは必要ない．
※ASPカーネルでは保護ドメイン，クラスは存在しないため，それらによるエラー
  コードが返ることを確認するテストの必要はない．
※ASPカーネル/FMPカーネルでは待ち禁止状態はサポートしていないため，テス
  トの必要はない．
※ASPカーネル/FMPカーネルでは待ちオブジェクトの削除はサポートしていない
  ため，テストの必要はない．
※"ディスパッチ保留状態"は，非タスクコンテキストの実行中，CPUロック状態，
  割込み優先度マスクが全解除でない状態，ディスパッチ禁止状態の4つ状態を
  テスト対象とする．
※複数のエラー要因がある場合に返るエラーコードは保証されないため，テス
  ト対象外とする．(CPUロックかつディスパッチ禁止状態など)

1.2 正常条件のテストケース
~~~~~~~~~~~~~~~~~~~~~~~~~~
統合仕様書を基に正常条件のテストケースを記述する．
但し，API仕様で記載された仕様だけでなく，統合仕様書全体から読み取れる
仕様から必要なテストケースを洗い出すこと．
テストケース毎に，エラー条件のテストケースと同様に連続したアルファベッ
トで番号を付与する．
但し，テストケースの番号が重複しないよう，エラー条件のテストケースから
連続したアルファベットで付与する．
静的APIで警告メッセージが出力されるテストを実施する場合も，正常条件とし
て取り扱う．

※特にテストケース作成漏れを注意すべき仕様
・ディスパッチが発生しても，ディスパッチ禁止状態の場合はタスクが切り替
  わらない．

※日本語言い回しの注意事項
・FMPカーネル拡張を考慮し，"自タスク"が"実行状態のタスク"でも通じる場合
  は，極力"実行状態のタスク"を使用する．
・「○○のとき，」ではなく「○○の場合，」を使用する．

----------------------------------------------------------------------
2. ソースコードの条件網羅確認
----------------------------------------------------------------------
2.1. ソースコード
~~~~~~~~~~~~~~~~~
対象とするバージョンのソースコードをSVNからチェックアウトし，各APIの仕
様の部分をそのままコピー＆ペーストする．

静的APIの場合，対象APIに関するチェック処理をkernel.tf，kernel_check.tf
ファイルから切り出して行数を付与して記載する．

2.2. マクロを展開したAPIと呼び出す内部関数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
対象とするAPIのマクロを展開したソースコードを行数を付加して記載する．
API内で呼び出している関数(内部関数と呼ぶ)については展開しない．
APIのソースコードのタイトルを[A]として，内部関数がある場合，内部関数の
ソースコードのタイトルを[B]として記載する．内部関数の中でさらに内部関数
を呼び出している場合は，その内部関数のソースコードも順番に[C]以降として
タイトルを振って記載する．この際，他のAPIにおいて，網羅確認を行っている
内部関数については，記載しない．どの内部関数をどの内部関数で網羅したか
は後述の内部関数網羅対象API一覧を参照のこと．なお，ターゲット依存部の内
部関数および，分岐のない内部関数については対象外とする．
内部関数内にマクロがある場合は，展開した上で記載する．
内部関数の中で，コールバック関数を登録する処理があった場合，そのコール
バック関数の条件網羅もそのAPIテスト内で行う．

※マクロ展開時の注意事項
  引数のあるマクロの場合，元のソースの変数名を継承して記載する．
  (例)#define EXT_TSKPRI(x) ((PRI)(x) + TMIN_TPRI)
      EXT_TSKPRI(p_tcb->priority);
      →((PRI)(p_tcb->priority) + TMIN_TPRI);

※ターゲット依存であるマクロは展開しない
  (例)dis_int，ena_intのVALID_INTPRI_CHGIPM(intpri)

2.3. 条件式
~~~~~~~~~~~
APIおよび内部関数内に存在するif文等の条件式を列挙する．条件式には2.2節で
割り振ったAから始まる関数毎のアルファベットに連番の数字を付与した番号を
割り当てる．割り当てた番号，行数，条件式を出現する順番に記載する．

静的APIの場合，以下のようなターゲット依存のマクロ定義の有無を判断する
条件式は除外する．
■マクロ定義があるものとする
・CHECK_STKSZ_ALIGN
・CHECK_FUNC_ALIGN
・CHECK_FUNC_NONNULL
・CHECK_STACK_ALIGN
・CHECK_STACK_NONNULL
・CHECK_MPF_ALIGN
・CHECK_MPF_NONNULL

■マクロ定義がないものとする
・USE_TSKINICTXB
・TARGET_MIN_STKSZ
・LENGTH(FIND(INTNO_FIX_KERNEL, intno))
・LENGTH(FIND(INTNO_FIX_NONKERNEL, intno))
・LENGTH(FIND(INHNO_FIX_KERNEL, inhno))
・LENGTH(FIND(INHNO_FIX_NONKERNEL, inhno))

静的APIの場合，以下のようなオブジェクトの存在有無を判断する条件式は
除外する．
■存在するものとする
・LENGTH(ALM.ID_LIST)
・LENGTH(CYC.ID_LIST)
・LENGTH(DTQ.ID_LIST)
・LENGTH(FLG.ID_LIST)
・LENGTH(MBX.ID_LIST)
・LENGTH(MPF.ID_LIST)
・LENGTH(PDQ.ID_LIST)
・LENGTH(SEM.ID_LIST)
・LENGTH(INTNO[inhno])
・LENGTH(INTNO[INH.INHNO[inhno]])

また，オブジェクトIDの重複チェックを行う条件式は，2.1節では記載されない
が，テストは実施されているため，条件網羅チェックの対象外とする．

2.4. 条件網羅表
~~~~~~~~~~~~~~~
1.2節のテストケースを縦，2.3節の条件式を横にとった条件網羅表を記載する．
テストケース毎に各条件式がTrue/False/Don'tCareなのかをT/F/Dで記載する．
また，ポインタのアドレス比較など，テストを実行しない限り，条件式の評価
結果が不定なものについては?とする．

※ソースコードの途中でテストケースとしての評価が終わる場合
  API発行によって，そのAPIのソースコードがすべて実行されることが保証さ
  れない,すなわちソースコードの途中でテストケースとしての評価が終わる場
  合，評価されないソースコード上にある条件式については"D(don't care)"と
  にする．
  (例)APIを発行するタスクが，ディスパッチが発生して実行可能状態となる場
      合や，待ち状態となる場合．

※動作環境(G_LOCK/P_LOCK)の網羅確認
  動作環境によるT、Fに分岐する条件式の場合
  動作環境の変更による同一テストケースから網羅可能になるためテストシート
  の網羅表にはT|Fと記述する．

  (例)IF EQ(+TTYPE_KLOCK, +P_KLOCK)

        (A1)
   (a)  T|F

本テストスイートでは，条件分岐網羅を100％とすることを目的とするため，
すべての条件判定において，結果が必ず一度は真と偽になるようにテストケー
スを設計する．従って，2.4節の条件網羅表を作成した結果として，真の判定し
か行われていない，もしくは偽の判定しか行われていない，という条件式が存
在する場合は，統合仕様書から読み取ることの出来ないホワイトボックステス
トとして，追加でテストを実施する．
条件網羅表で全ての条件式が一度は真偽となっている場合は，ホワイトボック
ステストの必要はないため，3章を作成する必要はない．
条件網羅表に各条件毎に一度は真偽となっている場合は"O"を，そうでない場合
は"X"を記入する．

※網羅できない条件式が存在する場合
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
タイミングに依存する等で網羅出来ない条件式があれば，備考に明記してTTSP
のユーザーズマニュアルに，"テスト実施対象外である事項"として記載する．
(T.B.D. : 今後ISS拡張により実施可能となる可能性がある)

FMPカーネルにおいてはタイミングに依存するテストである以下の内部関数が分
岐がある場合でも条件式や条件網羅表として扱わない．
色んなAPIの中で使われている内部関数がタイミング依存で網羅できない場合は
テストシートの備考に書く必要は無く，ここでまとめて明記する．

・i_acquire_nested_tsk_lock
・t_acquire_nested_tsk_lock
・t_acquire_nested_tsk_lock_self

※任意のマクロにより判定結果が変わる場合
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
任意のマクロを用いることにより真偽の判定結果が変わる場合は，TTGの
configure.yamlで定義したデフォルト値を用いた場合の判定結果を条件網羅表
に記載する．


----------------------------------------------------------------------
3. ホワイトボックステスト
----------------------------------------------------------------------
3.1. 条件網羅表
~~~~~~~~~~~~~~~
条件分岐網羅ができていない条件式に対して，不足している条件を実行するた
めの条件網羅表を作成する．例えばTrueしか実施されていない条件式があった
場合はFalseとなるテストケースを1つ作成すればよい．
テストケースの番号はホワイトボックステストであることが明確になるように
(W_a)から順に(W_b)，(W_c)と，"W_"を先頭に付与し，アルファベットを振る．

さらに，条件の不足に加え，以下の6パターンについては，単にTrue/Falseを
1回実施するだけでなく，それぞれ記載した内容で網羅を行う．

1)複数条件を含む条件式について
  if (A && B){ ... }
  上記のケースの場合，AがFalseの時点でBの判定が行われないため，Bが
  Don't Careとなるが，Aの判定に不具合があり，Trueが返ってきた場合に備え，
  BはDon't CareでなくTrueとしておく必要がある．こうすることでAの判定に
  不具合があった場合も，想定していない実行結果となりエラーとなる．
  テストシートの網羅表には以下のように記述する．

      (A) (B)
  (a)  F  D/T
  (b)  T   F
  (c)  T   T

  同様に if (A || B){ ... } の場合は，
      (A) (B)
  (a)  T  D/F
  (b)  F   T
  (c)  F   F
  となる．

2)while文の網羅確認
  while文の網羅確認は以下のように3回ループすることまで確認する．
  これはカーネル内におけるwhile文の使用方法から3回ループさせれば十分で
  あると判断したためである．
  whileの中にif文が存在する場合は，他の条件式同様，真偽が一度でも通る
  ようにテストケースを作成する．

  while(A){
    if(B) break;
  }
                          (A)  (B)
  Aが成立しない            F    D
  Aが1回成立               TF   F
  Aが2回成立               TTF  FF
  Aが3回成立               TTTF FFF
  Aが1回成立してBでbreak   T    T

3)do-while文の網羅確認
  do-while文はcall_texrtnでしか使用されず，ループ内でbreakするパスが無
  い．call_texrtnではタスク例外保留要因の有無のみをチェックするループで
  あるため，以下の確認のみとする．

  do {
  } while(A)
                          (A)
  Aが成立しない            F
  Aが1回成立               TF

4)for文の網羅確認
  for文はループ継続条件を条件式とする．
  for文の網羅確認は以下のように3回ループすることまで確認する．
  これはカーネル内におけるfor文の使用方法から3回ループさせれば十分で
  あると判断したためである．
  forの中にif文が存在する場合は，他の条件式同様，真偽が一度でも通る
  ようにテストケースを作成する．

  for(XXX; A; YYY){
    if(B) break;
  }
                          (A)  (B)
  Aが成立しない            F    D
  Aが1回成立               TF   F
  Aが2回成立               TTF  FF
  Aが3回成立               TTTF FFF
  Aが1回成立してBでbreak   T    T

5)switch文の網羅確認
  switch文の網羅確認は以下のように全てのcase文を実行することで確認する．

  switch(A){
    case B:
      break;
    case C:
      break;
    case D:
      break;
  }

        (B)  (C)  (D)
  A==B   T   D/F  D/F
  A==C   F    T   D/F
  A==D   F    F   T

6)静的APIのTNUM_PRCIDを使うFOREACH文の網羅確認
  NUM_PRCIDはターゲット依存のためTNUM_PRCIDに対する条件分岐が必要な場合は
  TNUM_PRCIDの値を２として2回ループさせることとする．

  (例) $FOREACH prcid RANGE(1, TNUM_PRCID)$
            ...
         $IF LENGTH(INI.CLASS[order])$
            ...
       $END$

        (A1)
   (a)   FT

3.2. テストケース
~~~~~~~~~~~~~~~~~
3.1節で作成した条件を満たすテストケースを記述する．1.1節，1.2節の体裁で
記述する必要はなく，必要な条件を列挙する形式で記述する．


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
テストシート作成時の注意事項
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(1)ファイルフォーマットはEUC+LFとする．

(2)タブ幅は半角スペース4つ分とする．

(3)1行に記述する文字数は原則半角70文字とする．
   但し，半角1文字分はみ出る場合や文末に句読点がある場合を考慮し，最大
   で半角73文字まで1行に記述できることとする．

(4)本ドキュメント同様，句点は"．"，読点は"，"を使用する．

(5)英数字記号は原則半角を使用する．但し全角でしか入力できない以下のよう
   な記号は全角を使用する．
   〔，〕，【，】


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TESRYデータ作成時の注意事項
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
テストID
----------------------------------------------------------------------
TESRYデータにテスト内容を記載する際，先頭にテストIDを記述するが，テスト
内容に合わせて，以下のフォーマットのテスト名とする．

カーネル名_機能名_API名_テスト番号
(例)
 ASP_task_manage_act_tsk_a
 FMP_task_sync_can_wup_c_1


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
テストケース抽出ポリシー
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下のテストポリシーを考慮してテストケースを抽出する．

----------------------------------------------------------------------
非タスクコンテキスト
----------------------------------------------------------------------
非タスクコンテキストからAPIを呼び出す場合，ターゲットに依存せず実行でき
るアラームハンドラを使用する．

※注意事項
  TOPPERSでは非タスクコンテキスト終了時にCPUロック状態を解除する仕様と
  なっているため，CPUロック状態で非タスクコンテキストからAPIを発行した
  後に，後状態として確認するポイントが，非タスクコンテキスト内か，非タ
  スクコンテキスト終了後かで，CPUロックの状態に矛盾がないよう  考慮する
  必要がある(例1)．また，CPUロックを非タスクコンテキストから解除する場
  合，非タスクコンテキスト終了による解除なのか，APIによる解除なのかを
  判別するため，非タスクコンテキスト内を後状態とする必要がある(例2)．
  (例1)CPUロック状態でiact_tskを発行する．
       [前状態]アラームハンドラ: 実行中
               CPUロック状態   : ロック
       [後状態]アラームハンドラ: 実行中
               CPUロック状態   : ロック
  (例2)CPUロック状態でiunl_cpuを発行する．
       [前状態]アラームハンドラ: 実行中
               CPUロック状態   : ロック
       [後状態]アラームハンドラ: 実行中
               CPUロック状態   : 解除

----------------------------------------------------------------------
タスク優先度
----------------------------------------------------------------------
テストで複数のタスクに対して優先度の高低差が必要な場合，高，中，低から
任意に組み合わせる．(全組み合わせは必要ない)
タスクが1つの場合など，優先度の高低差が必要ない場合は，優先度は省略する．
※TTGのconfigure.yamlの優先度マクロ設定を変更することで全優先度に対する
  テストが実施できる．

----------------------------------------------------------------------
自タスクの指定
----------------------------------------------------------------------
引数に自タスクを指定する場合，get_tcb_self()内の分岐を網羅するために，
引数に与えるタスクIDは，TSK_SELFを指定する.
(0もしくは自タスクのタスクIDを指定しない)
TSK_SELF以外に，TPRI_SELF，TPRI_INI，TPRC_INIにおいても同様に直接対象の
IDを指定するテストは実施しない．

----------------------------------------------------------------------
テスト対象とするタスク状態について
----------------------------------------------------------------------
様々な状態のタスクに対して，APIを発行する場合，全状態に対してテストを実
施するのは非効率であるため，カーネル仕様上，動作の異なる可能性のある以
下の10種類の状態についてテストすることとする．
(1) TTS_RUN 0x01U 実行状態
(2) TTS_RDY 0x02U 実行可能状態
    TTS_WAI 0x04U 待ち状態
(3)   TTW_SLP  0x0001U 起床待ち
(4)   TTW_DLY  0x0002U 時間経過待ち
(5)   TTW_SEM  0x0004U セマフォの資源獲得待ち(タイムアウト無)
(6)   TTW_SEM  0x0004U セマフォの資源獲得待ち(タイムアウト有)
(7) TTS_SUS 0x08U 強制待ち状態
    TTS_WAS 0x0cU 二重待ち状態
(8)   TTW_SLP  0x0001U 起床待ち
(9)   TTW_DLY  0x0002U 時間経過待ち
(10)TTS_DMT 0x10U 休止状態

(T.B.D. : 今後ツール等で"全状態でテストする"という機能が実装された場合，
          上記ポリシーは変更する．)

----------------------------------------------------------------------
周期ハンドラの動作確認
----------------------------------------------------------------------
周期ハンドラの正常動作は，5回ハンドラが起動したことで確認する．
これは実際に開発現場でRTOSのテストを行っているエンジニアからヒアリング
し，取り決めた確認方法である．
(例)
位相1，周期3であれば，0で起動(sta_cyc)し，2，5，8，11，14の5箇所で確認
する．

----------------------------------------------------------------------
同期通信オブジェクト用API
----------------------------------------------------------------------
同期通信オブジェクト用APIには対称性があるため，別途object.xlsに定めた
ポリシーに従って，テストケースを抽出する．
ただし，イベントフラグはobject.xlsに加え，次項のポリシーを適用する．
また，固定長メモリプールを取得するAPIについては，取得したアドレスの番地
が正しいことを確認するテストケースを追加する．

----------------------------------------------------------------------
イベントフラグのテストについて
----------------------------------------------------------------------
■指定するビットパターン
ビットパターンはすべてマクロを使用し，|(or演算子)を用いてテストケースに
合わせて条件が整うようにする．ただし，用意するマクロはすべてビットユニ
ークとなるよう定義する．
※TTGのconfigure.yamlのビットパターンマクロ設定を変更することで全ビット
  パターンに対するテストが実施できる．

■待ち行列を解除するテストケースにおける待ちモード
待ちモードは基本としてマクロを使用し，AND/ORに関わらずテストが可能とな
るようTESRYデータを作成する．ただし，set_flg/iset_flgにおける3つの待ち
タスクを待ち解除するテストケースにおいては，3つのタスクに異なる待ち条件
のビットパターンを指定し，引数にはOR条件で指定したビットパターンのタス
クのみ解除されることを確認する．テストケースと待ちモードの組み合わせビ
ットパターンは以下とする．

3つの待ちタスクの待ちモードの組み合わせは以下の8通りである．

    TASK1 TASK2 TASK3
W1:  OR    AND   AND
W2:  AND   OR    AND
W3:  AND   AND   OR
W4:  OR    OR    AND
W5:  OR    AND   OR
W6:  AND   OR    OR
W7:  AND   AND   AND
W8:  OR    OR    OR

3つの待ちタスクを解除するビットパターンの組み合わせは以下の7通りである．

R1: 1番目のみ解除
R2: 2番目のみ解除
R3: 3番目のみ解除
R4: 1，2番目のみ解除
R5: 1，3番目のみ解除
R6: 2，3番目のみ解除
R7: 3つ同時解除[TA_NULL]
R8: 3つ同時解除[TA_CLR] (TA_CLRのため1番目のみ解除される)

上記2つのパラメータは依存しないため，掛け算はせず，以下の8パターンを
テストケースの条件とする．
W1+R1，W2+R2，W3+R3，W4+R4，W5+R5，W6+R6，W7+R7，W8+R8

----------------------------------------------------------------------
タイムアウト付きAPIの振舞い
----------------------------------------------------------------------
タイムアウト付きAPIは，TMO_POLを指定すると，ポーリングを行うAPIと同じ振
舞いをし，TMO_FEVRを指定すると，タイムアウトなしのAPIと同じ振舞いをする
という仕様があるが，同じ振舞いをする仕様についての確認は本テストスイー
トでは実施しない．
(T.B.D. : 今後ツール等で"同じテストを別のAPIで実行する"という機能が実装
          された場合，上記ポリシーは変更する．)

----------------------------------------------------------------------
対象でないAPIに対するエラーコード確認
----------------------------------------------------------------------
待ちを解除する側のAPIに対するテストと，解除される側のAPIに対するテスト
で，全く同じ内容のテストとなる場合は，必要なしとする．
(例)slp_tskしたタスクがrel_waiされてE_RLWAIが返る
    →slp_tsk側でE_RLWAIが返ることは確認するが，
      rel_wai側で待ち解除したタスクにE_RLWAIが返ることは確認しない．

----------------------------------------------------------------------
境界値分析法の適用
----------------------------------------------------------------------
ID指定やタイムアウト値指定など，引数に数値を指定するAPIにおいて，不正値
をテストする場合，境界値分析法を適用し許容される最小値-1と最大値+1をテ
ストする．

■特殊なパラメータ
・RELTIM dlytim (相対時間)
  RELTIMは符号無し整数型であるため，最小値-1は負数となり有り得ない数値
  であるが，指定可能であるため，テストを実施する．最大値はTMAX_RELTIM
  として定義されるため，最大値+1はTMAX_RELTIM+1となる．

・TMO tmout (タイムアウト時間)
  TMOは符号付きの整数型であり，TMO_FEVR(=-1)を指定することで，"永久"を
  意味する．TMO_FEVR以外の負数は指定できないため，最小値-1はTMO_FEVR-1
  となる．また，システム時刻は符号無し整数型であるため，TMOに対する上限
  値は定義されていない．従ってTMO型に対する最大値+1のテストは不要となる．

----------------------------------------------------------------------
chg_priのテストケース
----------------------------------------------------------------------
優先度を変更する際に発生し得る状態として，以下のテストケースを実施する．
なお，自タスクは常に最高優先度であるため，自タスクの優先度を上げるとい
うテストは実施しない．

※chg_priを発行するタスクを自タスク(自)，自タスク以外のタスクを他タスク
 (他)とする．

■自タスクに対して発行するテストケース

       |自タスク後状態|
前状態 | 高 | 中 | 低 |
-----------------------  01: 他タスクが実行状態となる(優先順位が下がる)
自: 高 | ○ | ○ | × |  02: 他タスクが実行状態となる(優先度が下がる)
他: 高 | 01 | 02 | 03 |  03: 02と等価のため実施しない
-----------------------  04: 自タスクが実行状態のまま(優先度が変化しない)
自: 高 | ○ | ○ | ○ |  05: 他タスクが実行状態となる(優先度が同じ)
他: 中 | 04 | 05 | 06 |  06: 他タスクが実行状態となる(優先度が低い)
-----------------------  07: 04と等価のため実施しない
自: 高 | × | ○ | × |  08: 自タスクが実行状態のまま(優先度が下がる)
他: 低 | 07 | 08 | 09 |  09: 05と等価のため実施しない
-----------------------

■他タスクに対して発行するテストケース

       |他タスク後状態|
前状態 | 高 | 中 | 低 |
-----------------------  01: 他タスクが実行状態となる(優先度が上がる)
自: 中 | ○ | ○ | ○ |  02: 自タスクが実行状態のまま(優先順位が下がる)
他: 中 | 01 | 02 | 03 |  03: 自タスクが実行状態のまま(優先度が下がる)
-----------------------  04: 他タスクが実行状態となる(優先度が上がる)
自: 中 | ○ | ○ | ○ |  05: 自タスクが実行状態のまま(優先順が上がる)
他: 低 | 04 | 05 | 06 |  06: 自タスクが実行状態のまま(優先度が変化しない)
-----------------------

■待ちタスクの優先度を変更するテストケース
優先順属性のオブジェクト待ちのタスクの優先度を変えて，待ち行列の順序が
変わるテストを以下の観点で実施する．
・TASK1(中)→TASK2(中)→TASK3(低)のときにTASK2を高にする．
・TASK1(高)→TASK2(中)→TASK3(低)のときにTASK1を中にする．
・TASK1(高)→TASK2(中)→TASK3(中)のときにTASK2を低にする．
・TASK1(高)→TASK2(中)→TASK3(中)→TASK4(低)のときにTASK2を中にする．
また，順序が変わらない確認としてFIFO属性の場合も実施する．

■ディスパッチ保留状態について
ディスパッチが発生するテストケースにおいて，それぞれディスパッチ保留状
態を考慮するとテストケース数が肥大化する．ディスパッチ保留状態は他のAPI
で十分にテストケースを用意しており，chg_priの振舞い自体に直接関係しない
ため対象外とする．

----------------------------------------------------------------------
get_utmのテストケース
----------------------------------------------------------------------
SkyEye環境ではスクラッチテストでもマイクロ秒の時間計測は出来ないため，
戻り値の正当性は確認できない．従って分岐の網羅だけを行う．
本テストスイートはタイムティック=1msのみを対象としているため，
「TIC_DENO = 1」の場合のソースコードのみを対象とする．
「clock1 > clock2」の分岐はタイミングに依存するため網羅対象としない．

----------------------------------------------------------------------
rot_rdqのテストケース
----------------------------------------------------------------------
タスクの優先順位の回転する際に発生し得る状態として，以下のテストケース
を実施する．

※tskpriで指定した優先度を対象優先度とする．

■対象優先度を持つ実行できる状態のタスクが2つ．(1)

■対象優先度を持つ実行できる状態のタスクが3つ．(2)

タスクが2つある場合のテストは最も優先順位が高いタスクと次のタスクが
回転するという誤解の可能性もあるため「最も優先順位が高いタスクを，
同じ優先度のタスクの中で最も優先順位が低い状態にする」という仕様を証明
するためにはタスクが3つ以上が必要になる．

----------------------------------------------------------------------
タスクが起動するときに行われるべきの処理の確認方法
----------------------------------------------------------------------
以下のパラメータが初期化されたことを確認する．
・現在優先度
・起動要求キューイング数
・起床要求キューイング数
・タスク例外禁止フラグ
・タスク例外保留要因


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TESRYデータ作成ポリシー
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
----------------------------------------------------------------------
任意の値
----------------------------------------------------------------------
以下のような任意に値を設定できるパラメータについては，マジックナンバー
を使用せず，TTGで用意されている任意であることを示すマクロを使用する．

・タスク優先度
・データ優先度
・メッセージ優先度
・イベントフラグビットパターン
・送受信データ
・拡張情報
・タイムアウト値
  ・永久待ちと見なす時間
  ・経過時間
・相対時間
・セマフォ
  ・最大資源数
  ・現在資源数
  ・初期資源数
・固定長メモリプール
  ・固定長メモリブロックの(最大)数
  ・固定長メモリブロックの(現在)数
  ・ブロックサイズ
・例外要因ビットパターン
・割込み優先度マスク

----------------------------------------------------------------------
非タスクコンテキストの取り扱い
----------------------------------------------------------------------
APIテストの観点において，非タスクコンテキストからAPIを発行するテストケ
ースの場合，post_conditionのAPIを発行した非タスクコンテキストは実行状態
とままとするべきである．非タスクコンテキストが終了することによるディス
パッチによって，実行状態のタスクが切り替わることを確認するのは，処理単
位テストの範疇であるが，新たに処理単位テストで同様のテストケースを，全
APIで開発するのは冗長となるため，以下のようにAPIテストと合わせて確認を
行うものとする．

(例) ※APIテストの範疇は，post_condition_0までである
ASP_task_manage_iact_tsk_d_1_1:
  pre_condition:
    ALM1:
      type   : ALARM
      almstat: TALM_STP
      hdlstat: ACTIVATE

    TASK1:
      type   : TASK
      tskpri : TSK_PRI_MID
      tskstat: running

    TASK2:
      type   : TASK
      itskpri: TSK_PRI_HIGH
      tskstat: dormant

  do_0:
    id     : ALM1
    syscall: iact_tsk(TASK2)
    ercd   : E_OK
    gcov   : true

  post_condition_0:
    TASK2:
      tskstat: ready
      tskpri : TSK_PRI_HIGH

  do_1:
    id     : ALM1
    code   : return
    gcov   : false

  post_condition_1:
    ALM1:
      almstat: TALM_STP
      hdlstat: STP

    TASK1:
      tskstat: ready

    TASK2:
      tskstat: running

--------------------------------------------------------------------
ターゲット依存のパラメータ
----------------------------------------------------------------------
ターゲット毎に正常値/異常値が異なるパラメータについては，ターゲット毎に
用意するttsp_target_test.hで定義されているマクロを使用する．

----------------------------------------------------------------------
変数の初期化
----------------------------------------------------------------------
APIを発行してE_OK以外のエラーコードが返るテストケースについては，引数に
与えた変数が，API発行前から変化が無いことをテストする必要がある．従って，
E_OK以外のエラーコードが返るテストケースで，APIの引数に変数のポインタを
指定する場合は，pre_conditionの変数定義で初期値を与える．設定する値は任
意の値でよいため，マクロを使用する．

----------------------------------------------------------------------
割込み番号の使用
----------------------------------------------------------------------
TTSPでは，割込みハンドラ用に3つ(割込み優先度:高/中/低)，割込みサービス
ルーチン用に3つ(割込み優先度:高/中/低)，割込み番号を用意することを想定
している．しかし，割込み番号毎にCFG_INTで指定する属性が，テストケースに
よって異なると，テストケースをマージできないため，以下の設定で割込み番
号を使用する．

割込み番号マクロ |   属性
----------------------------
INTNO_SELF_INH_A | TA_NULL
INTNO_SELF_INH_B | TA_ENAINT
INTNO_SELF_INH_C | TA_NULL
INTNO_SELF_ISR_A | TA_NULL
INTNO_SELF_ISR_B | TA_ENAINT
INTNO_SELF_ISR_C | TA_NULL

※APIテストにおいては，割込み優先度はANY_INT_PRI固定とする．
※割込みハンドラ番号はINTNO_SELF_INH_A→INHNO_SELF_Aのように，同じアル
  ファベットのマクロを使用する．

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
内部関数網羅対象API一覧
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
内部関数の条件網羅を，ASPカーネルのどのAPIで行ったかを以下にまとめる．

************************************
| 内部関数名            | API      |
************************************
| bitmap_search         | sus_tsk  |
| call_almhdr           | sta_alm  |
| call_cychdr           | sta_cyc  |
| call_texrtn           | ras_tex  |
| change_priority       | chg_pri  |
| check_flg_cond        | set_flg  |
| dequeue_data          | rcv_dtq  |
| enqueue_data          | psnd_dtq |
| enqueue_msg_pri       | snd_mbx  |
| enqueue_pridata       | snd_pdq  |
| force_enqueue_data    | fsnd_dtq |
| force_send_data       | fsnd_dtq |
| get_mpf_block         | get_mpf  |
| init_wait_queue       | ini_pdq  |
| make_active           | iact_tsk |
| make_non_runnable     | sus_tsk  |
| make_non_wait         | snd_pdq  |
| make_runnable         | iact_tsk |
| make_wait_tmout       | tsnd_pdq |
| primap_empty          | sus_tsk  |
| primap_search         | sus_tsk  |
| queue_empty           | sus_tsk  |
| queue_insert_tpri     | snd_pdq  |
| receive_data          | rcv_dtq  |
| receive_pridata       | rcv_pdq  |
| rotate_ready_queue    | rot_rdq  |
| search_schedtsk       | sus_tsk  |
| send_data             | psnd_dtq |
| send_pridata          | snd_pdq  |
| tmevt_down            | ini_pdq  |
| tmevt_lefttim         | ref_cyc  |
| tmevt_up              | dly_tsk  |
| tmevtb_delete         | ini_pdq  |
| tmevtb_dequeue        | ini_pdq  |
| tmevtb_enqueue        | dly_tsk  |
| tmevtb_enqueue_cyc    | sta_cyc  |
| tmevtb_enqueue_evttim | sta_cyc  |
| tmevtb_insert         | dly_tsk  |
| wait_complete         | snd_pdq  |
| wait_dequeue_tmevtb   | ini_pdq  |
| wait_dequeue_wobj     | rel_wai  |
| wait_release          | rel_wai  |
| wait_tmout            | tsnd_pdq |
| wait_tmout_ok         | dly_tsk  |
| wait_tskid            | ref_flg  |
| wobj_change_priority  | chg_pri  |
| wobj_make_wait        | snd_pdq  |
| wobj_make_wait_tmout  | tsnd_pdq |
| wobj_queue_insert     | snd_pdq  |
************************************

※以下の内部関数には分岐が存在しない
dequeue_pridata
make_dormant
make_wait
primap_clear
primap_set
queue_delete
queue_delete_next
queue_insert_prev

※以下の内部関数はターゲット依存である
activate_context
dispatch
exc_sense_intmask
exc_sense_unlock
exit_and_dispatch
i_get_ipm
i_lock_cpu
i_sense_lock
i_unlock_cpu
sense_context
t_get_ipm
t_lock_cpu
t_sense_lock
t_set_ipm
t_unlock_cpu
target_timer_get_current
target_timer_probe_int
x_disable_int
x_enable_int



以上．
